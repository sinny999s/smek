<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer 3D Snake</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Basic Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x111111);
        document.body.appendChild(renderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7.5);
        scene.add(dirLight);

        // --- Game Board ---
        const gridSize = 20;
        const gridHelper = new THREE.GridHelper(gridSize, gridSize, 0x444444, 0x444444);
        gridHelper.position.y = -0.5;
        scene.add(gridHelper);

        // --- Game Objects ---
        const foodGeometry = new THREE.BoxGeometry(1, 1, 1);
        const foodMaterial = new THREE.MeshLambertMaterial({ color: 0xff3333 });
        const foodMesh = new THREE.Mesh(foodGeometry, foodMaterial);
        scene.add(foodMesh);
        
        const playerMeshes = {};

        // --- Client-Side Prediction State ---
        let pendingInputs = [];
        let inputSequenceNumber = 0;
        let localPlayerDirection = { x: 1, y: 0, z: 0 };

        // --- WebSocket Connection ---
        const ws = new WebSocket('wss://sinny-snake-server.onrender.com');
        let myId = null;

        ws.onopen = () => console.log('Connected to the server!');
        ws.onmessage = (event) => {
            const gameState = JSON.parse(event.data);

            if (gameState.type === 'assign_id') {
                myId = gameState.id;
                console.log(`I am player ${myId}`);
                return;
            }

            if (gameState.type === 'game_update') {
                // --- Server Reconciliation ---
                if (myId && gameState.players[myId]) {
                    const myServerState = gameState.players[myId];
                    // The server has confirmed a position for our snake.
                    // We can now safely set our local snake's mesh to this state.
                    const myMeshArray = playerMeshes[myId] || [];
                    for(let i = 0; i < myServerState.snake.length; i++) {
                        if(myMeshArray[i]) {
                           myMeshArray[i].position.set(myServerState.snake[i].x, myServerState.snake[i].y, myServerState.snake[i].z);
                        }
                    }

                    // Remove inputs that the server has already processed.
                    pendingInputs = pendingInputs.filter(input => input.sequence > myServerState.sequence);

                    // Re-apply any inputs that happened after the server's last processed state.
                    // This corrects our position if there was a prediction error.
                    pendingInputs.forEach(input => {
                        // (In a more complex game, we'd re-simulate the move here)
                        localPlayerDirection = input.direction;
                    });
                }

                // --- Render other players ---
                for (const id in gameState.players) {
                    if (id == myId) continue; // Skip our own snake

                    const player = gameState.players[id];
                    if (!playerMeshes[id]) playerMeshes[id] = [];
                    
                    const meshArray = playerMeshes[id];
                    const snakeData = player.snake;

                    while (meshArray.length < snakeData.length) {
                        const geometry = new THREE.BoxGeometry(1, 1, 1);
                        const material = new THREE.MeshLambertMaterial({ color: player.color });
                        const segment = new THREE.Mesh(geometry, material);
                        meshArray.push(segment);
                        scene.add(segment);
                    }
                    while (meshArray.length > snakeData.length) {
                        const segmentToRemove = meshArray.pop();
                        scene.remove(segmentToRemove);
                    }

                    for (let i = 0; i < snakeData.length; i++) {
                        meshArray[i].position.set(snakeData[i].x, snakeData[i].y, snakeData[i].z);
                    }
                }

                // --- Update Food ---
                foodMesh.position.set(gameState.food.x, gameState.food.y, gameState.food.z);
            }
        };

        // --- Controls ---
        window.addEventListener('keydown', (event) => {
            let direction;
            switch (event.key.toLowerCase()) {
                case 'arrowup': case 'w': direction = { x: 0, y: 0, z: -1 }; break;
                case 'arrowdown': case 's': direction = { x: 0, y: 0, z: 1 }; break;
                case 'arrowleft': case 'a': direction = { x: -1, y: 0, z: 0 }; break;
                case 'arrowright': case 'd': direction = { x: 1, y: 0, z: 0 }; break;
                default: return;
            }

            // Client-side prediction: update local direction immediately
            if(direction.x !== -localPlayerDirection.x || direction.z !== -localPlayerDirection.z) {
                localPlayerDirection = direction;
                const sequence = ++inputSequenceNumber;
                pendingInputs.push({ sequence, direction });
                ws.send(JSON.stringify({ type: 'direction_change', direction, sequence }));
            }
        });

        // --- Camera & Rendering ---
        camera.position.set(0, 15, 12);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        const clock = new THREE.Clock();
        let timeSinceLastMove = 0;
        const moveInterval = 0.150; // 150ms

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            timeSinceLastMove += delta;

            // --- Move local player predictively ---
            if (myId && playerMeshes[myId] && timeSinceLastMove >= moveInterval) {
                timeSinceLastMove = 0;
                const myMeshArray = playerMeshes[myId];
                const headPos = myMeshArray[0].position.clone();

                // Move all but the head to the position of the one in front
                for(let i = myMeshArray.length - 1; i > 0; i--) {
                    myMeshArray[i].position.copy(myMeshArray[i-1].position);
                }
                // Move the head
                myMeshArray[0].position.add(localPlayerDirection);
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
