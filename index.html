<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer 3D Snake</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Basic Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x111111);
        document.body.appendChild(renderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7.5);
        scene.add(dirLight);

        // --- Game Board ---
        const gridSize = 20;
        const gridHelper = new THREE.GridHelper(gridSize, gridSize, 0x444444, 0x444444);
        gridHelper.position.y = -0.5;
        scene.add(gridHelper);

        // --- Game Objects ---
        const foodGeometry = new THREE.BoxGeometry(1, 1, 1);
        const foodMaterial = new THREE.MeshLambertMaterial({ color: 0xff3333 });
        const foodMesh = new THREE.Mesh(foodGeometry, foodMaterial);
        scene.add(foodMesh);
        
        const playerMeshes = {};

        // --- Interpolation State ---
        let serverStateBuffer = [];
        const RENDER_DELAY = 100; // ms

        // --- WebSocket Connection ---
        const ws = new WebSocket('wss://sinny-snake-server.onrender.com');
        let myId = null;

        ws.onopen = () => console.log('Connected to the server!');
        ws.onmessage = (event) => {
            const gameState = JSON.parse(event.data);
            if (gameState.type === 'assign_id') {
                myId = gameState.id;
                console.log(`I am player ${myId}`);
                return;
            }
            if (gameState.type === 'game_update') {
                // Instead of rendering immediately, we push the state to a buffer.
                serverStateBuffer.push({timestamp: Date.now(), state: gameState});
            }
        };

        // --- Controls ---
        window.addEventListener('keydown', (event) => {
            let direction;
            switch (event.key.toLowerCase()) {
                case 'arrowup': case 'w': direction = { x: 0, y: 0, z: -1 }; break;
                case 'arrowdown': case 's': direction = { x: 0, y: 0, z: 1 }; break;
                case 'arrowleft': case 'a': direction = { x: -1, y: 0, z: 0 }; break;
                case 'arrowright': case 'd': direction = { x: 1, y: 0, z: 0 }; break;
                default: return;
            }
            ws.send(JSON.stringify({ type: 'direction_change', direction: direction }));
        });

        // --- Camera & Rendering ---
        camera.position.set(0, 15, 12);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // --- Interpolation Logic ---
            const renderTime = Date.now() - RENDER_DELAY;
            
            // Find the two server updates we want to interpolate between
            let fromState = null;
            let toState = null;
            for(let i = serverStateBuffer.length - 1; i >= 0; i--) {
                if(serverStateBuffer[i].timestamp <= renderTime) {
                    fromState = serverStateBuffer[i];
                    toState = serverStateBuffer[i+1];
                    break;
                }
            }

            // Clean up old states
            if(serverStateBuffer.length > 20) {
                serverStateBuffer.splice(0, serverStateBuffer.length - 20);
            }

            if(fromState && toState) {
                const timeDiff = toState.timestamp - fromState.timestamp;
                const renderDiff = renderTime - fromState.timestamp;
                const t = Math.min(renderDiff / timeDiff, 1.0); // Interpolation factor (0.0 to 1.0)

                // --- Update Food (can snap, doesn't need lerp) ---
                foodMesh.position.set(fromState.state.food.x, fromState.state.food.y, fromState.state.food.z);

                // --- Update Snakes with Interpolation ---
                const receivedPlayerIds = Object.keys(fromState.state.players);
                
                for(const existingId in playerMeshes) {
                    if (!receivedPlayerIds.includes(existingId)) {
                        playerMeshes[existingId].forEach(segment => scene.remove(segment));
                        delete playerMeshes[existingId];
                    }
                }

                for (const id in fromState.state.players) {
                    const playerFrom = fromState.state.players[id];
                    const playerTo = toState.state.players[id];

                    if (!playerTo) continue; // Skip if player doesn't exist in the next state

                    if (!playerMeshes[id]) playerMeshes[id] = [];
                    
                    const meshArray = playerMeshes[id];
                    const snakeDataFrom = playerFrom.snake;
                    const snakeDataTo = playerTo.snake;

                    // Sync mesh array length
                    while (meshArray.length < snakeDataFrom.length) {
                        const geometry = new THREE.BoxGeometry(1, 1, 1);
                        const material = new THREE.MeshLambertMaterial({ color: playerFrom.color });
                        const segment = new THREE.Mesh(geometry, material);
                        meshArray.push(segment);
                        scene.add(segment);
                    }
                    while (meshArray.length > snakeDataFrom.length) {
                        const segmentToRemove = meshArray.pop();
                        scene.remove(segmentToRemove);
                    }

                    // Interpolate positions of all meshes
                    for (let i = 0; i < meshArray.length; i++) {
                        if(snakeDataFrom[i] && snakeDataTo[i]) {
                            const fromPos = new THREE.Vector3(snakeDataFrom[i].x, snakeDataFrom[i].y, snakeDataFrom[i].z);
                            const toPos = new THREE.Vector3(snakeDataTo[i].x, snakeDataTo[i].y, snakeDataTo[i].z);
                            meshArray[i].position.lerpVectors(fromPos, toPos, t);
                        }
                    }
                }
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
